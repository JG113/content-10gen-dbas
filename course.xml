<course url_name='2012_Fall' org='10gen' course='M102' start='2012-10-22T00:00' display_name='MongoDB for DBAs'><chapter graceperiod='1 day' start='2012-10-22T00:00' due='2012-10-31T03:00' display_name='week1'><sequential graded='false' format='Quiz' display_name='Course Overview'><vertical><video display_name='Lecture' youtube='1.0:0euni8AdT1c'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Concepts and Philosophy'><vertical><video display_name='Lecture' youtube='1.0:QUuYrMSPhL4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing on Unix'><vertical><video display_name='Lecture' youtube='1.0:6VFukRETCTg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing MongoDB on Windows'><vertical><video display_name='Lecture' youtube='1.0:hX5louVryOQ'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Types'><vertical><video display_name='Lecture' youtube='1.0:gKOcqNHmc4Q'/></vertical><problem showanswer='attempted' url_name='JSON_Types_problem' rerandomize='onreset' display_name='Quiz'>How many data types are there in JSON?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>1 (just strings)</text></choice><choice location='bottom' correct='false'><text>2</text></choice><choice location='bottom' correct='false'><text>4</text></choice><choice location='bottom' correct='true'><text>6</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:e2lfdSDENjY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Syntax'><vertical><video display_name='Lecture' youtube='1.0:a3jWXcmjrWM'/></vertical><problem showanswer='attempted' url_name='JSON_Syntax_problem' rerandomize='onreset' display_name='Quiz'><p>What is the corresponding JSON for the following XML document?</p>

<pre>
&lt;person&gt;
  &lt;name&gt;John&lt;/name&gt;
  &lt;age&gt;25&lt;/age&gt;
  &lt;address&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phones&gt;
    &lt;phone type="home"&gt;212-555-1234&lt;/phone&gt;
    &lt;phone type="mobile"&gt;646-555-1234&lt;/phone&gt;
  &lt;/phones&gt;
&lt;/person&gt;
</pre><customresponse><textbox rows='4' cols='50' correct_answer='{&#10;  "name" : "John",&#10;  "age" : 25,&#10;  "address" : {&#10;    "city" : "New York",&#10;    "postalCode" : "10021"&#10;  },&#10;  "phones" : [&#10;    {"phone":"212-555-1234", "type" : "home"},&#10;    {"phone":"646-555-1234", "type" : "mobile"}&#10;  ]&#10;}'/><answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{
  "name" : "John",
  "age" : 25,
  "address" : {
    "city" : "New York",
    "postalCode" : "10021"
  },
  "phones" : [
    {"phone":"212-555-1234", "type" : "home"},
    {"phone":"646-555-1234", "type" : "mobile"}
  ]
}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:RoUvl8c_3Sc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Syntax 2'><vertical><video display_name='Lecture' youtube='1.0:dxd1BnBqQk8'/></vertical><problem showanswer='attempted' url_name='JSON_Syntax_2_problem' rerandomize='onreset' display_name='Quiz'>For the following XML, Is the corresponding JSON example legal json?

<pre>
&lt;things&gt;
  &lt;hat&gt;one&lt;/hat&gt;
  &lt;coat&gt;z&lt;/coat&gt;
  &lt;hat&gt;two&lt;/hat&gt;
&lt;/things&gt;
</pre>

<pre>
{
  "hat" : "one",
  "coat" : "z",
  "hat" : "two"
}
</pre>
<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>yes</text></choice><choice location='bottom' correct='false'><text>no</text></choice><choice location='bottom' correct='true'><text>maybe</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:eypM73cF0dI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Introduction to BSON'><vertical><video display_name='Lecture' youtube='1.0:CEH0kNxVyMw'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='What is the Mongo Shell'><vertical><video display_name='Lecture' youtube='1.0:W4o8HJyL7_8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='What is JavaScript'><vertical><video display_name='Lecture' youtube='1.0:n1Hld15pvZY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='What is JavaScript 2'><vertical><video display_name='Lecture' youtube='1.0:n79mmmQxoNE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='mongoimport'><vertical><video display_name='Lecture' youtube='1.0:ZWnHhKiApVU'/></vertical><problem showanswer='attempted' url_name='mongoimport_problem' rerandomize='onreset' display_name='Quiz'>The mongoimport utility can import what types of data?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>CSV (comma separated values)<endouttext/></choice><choice correct='true'><startouttext/>TSV (tab separated values)<endouttext/></choice><choice correct='false'><startouttext/>XML<endouttext/></choice><choice correct='true'><startouttext/>JSON<endouttext/></choice><choice correct='false'><startouttext/>BSON<endouttext/></choice><choice correct='false'><startouttext/>plain text<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:8_6S7E9r9DQ'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Introduction to the MongoDB Shell'><vertical><video display_name='Lecture' youtube='1.0:P1yLtecuLM8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Shell: Queries'><vertical><video display_name='Lecture' youtube='1.0:Mjcd5PAdG-s'/></vertical><problem showanswer='attempted' url_name='Shell_Queries_problem' rerandomize='onreset' display_name='Quiz'>We have sample documents in our products collection such as:

<pre>
{
  name: "AC1 Case Green",
  color: "green",
  price: 12.00,
  for: "ac1",
  type: ["accessory", "case"],
  available: true
}
</pre>

How would we query in the shell for all products that are cases for an ac9 phone?  That is, where <i>type</i> contains the value "case" and <i>for</i> equals "ac9"?

<p><i>Please use field names in the order they appear in the question and use double quotes around values.</i></p><customresponse><textbox rows='4' cols='50' correct_answer='db.products.find({type: "case", for: "ac9"})'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.products.find({type: "case", for: "ac9"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:fYcPCRCPvDg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Shell:  Sorting'><vertical><video display_name='Lecture' youtube='1.0:Ezx1lXaY7jE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Shell: Cursors and Shell Help'><vertical><video display_name='Lecture' youtube='1.0:DRs4_hBpPlI'/></vertical><problem showanswer='attempted' url_name='Shell_Cursors_and_Shell_Help_problem' rerandomize='onreset' display_name='Quiz'>What would you type to see the help/man text for mongo cursors in the mongo administrative shell?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>help</text></choice><choice location='bottom' correct='false'><text>db.help()</text></choice><choice location='bottom' correct='false'><text>db.products.help()</text></choice><choice location='bottom' correct='false'><text>help misc</text></choice><choice location='bottom' correct='true'><text>db.products.find().help()</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:3KwsHVHBM9w'/></vertical></sequential><sequential graded='true' format='Homework' display_name='Homework 1.1'><problem showanswer='never' attempts='3' url_name='Homework_1_1_problem' rerandomize='onreset' display_name='Quiz'>Download and install MongoDB from www.mongodb.org.  Then run the database as a single server instance on your PC (that is, run the mongod binary).  Then, run the administrative shell.  From the shell prompt type 
<pre>
 db.isMaster().maxBsonObjectSize
</pre>
at the ">" prompt. What do you get as a result?<customresponse><textbox rows='4' cols='50' correct_answer="16777216"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''16777216'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 1.2'><problem showanswer='never' attempts='3' url_name='Homework_1_2_problem' rerandomize='onreset' display_name='Quiz'>Download the file <a href="/static/handouts/products.json">products.json</a> from education.10gen.com.
Take a look at its content.
Now, import its contents into MongoDB, into a database called "pcat" and a collection called "products".  Use the mongoimport utility to do this.
When done, run this query in the mongo shell:
<pre>
db.products.find({type:"case"}).count()
</pre>
What's the result?<customresponse><textbox rows='4' cols='50' correct_answer="3"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 1.3'><problem showanswer='never' attempts='3' url_name='Homework_1_3_problem' rerandomize='onreset' display_name='Quiz'>At this point you should have pcat.products loaded from the previous step. You can confirm this by running in the shell:
<pre>
> db.products.find()
> // or:
> db.products.count()
> // should print out "11"
</pre>
Now, what query would you run to get all the products where brand equals the string “ACME”?<customresponse><textbox rows='4' cols='50' correct_answer='db.products.find({brand:"ACME"})'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.products.find({brand:"ACME"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 1.4'><problem showanswer='never' attempts='3' url_name='Homework_1_4_problem' rerandomize='onreset' display_name='Quiz'>How would you print out, in the shell, the name of all the products without extraneous characters or braces, sorted alphabetically, ascending?  (Check all that would apply.)<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>db.products.find({},{name:1,_id:0}).sort({name:1})<endouttext/></choice><choice correct='true'><startouttext/>var c = db.products.find({},{name:1,_id:0}).sort({name:1}); 
while( c.hasNext() ) 
    print( c.next().name);
<endouttext/></choice><choice correct='true'><startouttext/>var c = db.products.find({}).sort({name:1});
c.forEach( function(doc){ print(doc.name) } );<endouttext/></choice><choice correct='false'><startouttext/>var c = db.products.find({}).sort({name:-1});
while( c.hasNext() ) 
    print( c.next().name);<endouttext/></choice></checkboxgroup></choiceresponse></problem></sequential></chapter><chapter graceperiod='1 day' start='2012-10-29T12:00' due='2012-11-6T03:00' display_name='week2'><sequential graded='false' format='Quiz' display_name='Inserting Data'><vertical><video display_name='Lecture' youtube='1.0:MWH-_nJgebw'/></vertical><problem showanswer='attempted' url_name='Inserting_Data_problem' rerandomize='onreset' display_name='Quiz'>In the mongo shell, what would you type to insert the document {x:3,y:4} into the "temperature" collection for the current database?<customresponse><textbox rows='4' cols='50' correct_answer="db.temperature.insert({x:3,y:4})"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.temperature.insert({x:3,y:4})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:Yl6L0jytr4o'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Updating Documents'><vertical><video display_name='Lecture' youtube='1.0:0tGJGxqvO0c'/></vertical><problem showanswer='attempted' url_name='Updating_Documents_problem' rerandomize='onreset' display_name='Quiz'>Suppose we have a collection "cars" with one document preexisting:
<pre>
{ "_id" : 100, "name" : "GTO", 
  "year" : 1969, "color" : "red" }
</pre>
Which of the following statements would set "available" to 1?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>db.cars.update({_id:100},{$set:{available:1}})<endouttext/></choice><choice correct='true'><startouttext/>db.cars.update({_id:100},{$inc:{available:1}})<endouttext/></choice><choice correct='true'><startouttext/>db.cars.update({},{$inc:{available:1,year:1970}})<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:sRjVWZ6olqI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='MongoDB Documents Quiz'><problem showanswer='attempted' url_name='MongoDB_Documents_Quiz_problem' rerandomize='onreset' display_name='Quiz'>Which of the following are true?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>MongoDB can store large things; for example a 1 terabyte video.<endouttext/></choice><choice correct='false'><startouttext/>On an update of a document in mongodb, the document always physically moves in its position in the data file(s).<endouttext/></choice><choice correct='false'><startouttext/>On average, mongodb documents have about the same number of fields as one would have in a relational database table for the same problem.<endouttext/></choice></checkboxgroup></choiceresponse></problem></sequential><sequential graded='false' format='Quiz' display_name='Removing documents'><vertical><video display_name='Lecture' youtube='1.0:qj7n4TRVY1M'/></vertical><problem showanswer='attempted' url_name='Removing_documents_problem' rerandomize='onreset' display_name='Quiz'>Suppose we have documents in a 'users' collection of the form:
<pre>
{
 _id : ObjectId("50897dbb9b96971d287202a9"),
 name : "Jane",
 likes : [ "tennis", "golf" ],
 registered : false,
 addr : {
   city : "Lyon",
   country : "France" 
 } 
}
</pre>
How would we, in the mongo shell, delete all documents in the collection where city = "Lyon" and registered is false?<customresponse><textbox rows='4' cols='50' correct_answer='db.users.remove({"addr.city":"Lyon",&#10;registered:false})'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.remove({"addr.city":"Lyon",
registered:false})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:WOzekUwo1vE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Updating Part 2'><vertical><video display_name='Lecture' youtube='1.0:pgu3nta2iLM'/></vertical><problem showanswer='attempted' url_name='Updating_Part_2_problem' rerandomize='onreset' display_name='Quiz'>Suppose we have documents in a 'users' collection of the form:
<pre>
{
 _id : "Jane",
 likes : [ "tennis", "golf" ],
 registered : false,
 addr : {
   city : "Lyon",
   country : "France" 
 } 
}
</pre>
How would we, in the mongo shell, add that this user likes "football"?<customresponse><textbox rows='4' cols='50' correct_answer='db.users.update({_id:"Jane"},{$addToSet:{likes:"football"}}, true)'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({_id:"Jane"},{$addToSet:{likes:"football"}}, true)'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:zKDmE590nlA'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='MongoDB Commands'><vertical><video display_name='Lecture' youtube='1.0:nAfLu7vKiRI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='MongoDB Commands 2'><vertical><video display_name='Lecture' youtube='1.0:0tnBD_hLUso'/></vertical><problem showanswer='attempted' url_name='MongoDB_Commands_2_problem' rerandomize='onreset' display_name='Quiz'>Which of these statements is true?
<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>MongoDB commands are for administrator use only.<endouttext/></choice><choice correct='true'><startouttext/>In MongoDB collections are usually created implicitly.<endouttext/></choice><choice correct='false'><startouttext/>In MongoDB indexes are usually created implicitly.<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:uktnp4cIjZk'/></vertical></sequential><sequential graded='true' format='Homework' display_name='Homework 2.1'><problem showanswer='never' attempts='3' url_name='Homework_2_1_problem' rerandomize='onreset' display_name='Quiz'>We will use the pcat.products collection from week 1.  So start with that; if not already set up, import it:
<pre>
mongoimport --db pcat -c products &lt; products.json
</pre>
You can find <a href="/static/handouts/products.json">products.json</a> on the education.10gen.com site. 
In the shell, if you type:
<pre>
db.products.count()
</pre>

should return 11.
<p>
Next, download <a href="/static/handouts/homework2.js">homework2.js</a> from the education.10gen.com site.  Run the shell with this script:</p>
<pre>
mongo --shell pcat homework2.js
</pre>

First, make a mini-backup of the collection before we start modifying it.  In the shell:

<pre>
b = db.products_bak; db.products.find().forEach( function(o){ b.insert(o) } )
 // check it worked: 
b.count()
// should print 11
</pre>

If you have any issues you can restore from "products_bak"; or, you can re-import with mongoimport.  (You would perhaps need in that situation to empty the collection first or drop it; see the --drop option on mongoimport --help.)

At the shell ">" prompt type: 
<pre>
homework.a()
</pre>

What is the output? (The above will check that products_bak is populated.)<customresponse><textbox rows='4' cols='50' correct_answer="3.05"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3.05'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.2'><problem showanswer='never' attempts='3' url_name='Homework_2_2_problem' rerandomize='onreset' display_name='Quiz'>Add a new product to the products collection of this form:
<pre>
{
	"_id" : "ac9",
	"name" : "AC9 Phone",
	"brand" : "ACME",
	"type" : "phone",
	"price" : 333,
	"warranty_years" : 0.25,
	"available" : true
}
</pre>
Note: in general because of the automatic line continuation in the shell, you can cut/paste in the above and shouldn't have to type it all out.  Just enclose it in the proper statement(s) to get it added.

Next, load into a shell variable the object corresponding to 
<pre>
_id : ObjectId("507d95d5719dbef170f15c00")
</pre>
<ul>
<li>Then change <code>term_years</code> to 3 for that document. (And save that to the database.)</li>
<li>Then change <code>over_rate</code> for <code>sms</code> in <code>limits</code> to 0.01 from 0.  Save that too.</li>
</ul>
At the shell prompt type: 
<pre>
homework.b()
</pre>
What is the output?<customresponse><textbox rows='4' cols='50' correct_answer="0.050.019031"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''0.050.019031'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.3'><problem showanswer='never' attempts='3' url_name='Homework_2_3_problem' rerandomize='onreset' display_name='Quiz'>How many products have a voice limit?  (That is, have a voice field present in the limits array.)<customresponse><textbox rows='4' cols='50' correct_answer="3"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.4'><problem showanswer='never' attempts='3' url_name='Homework_2_4_problem' rerandomize='onreset' display_name='Quiz'>Create an index on the field <code>for</code>.

You might want to first run the following to get some context on what is present in that field in the documents of our collection:
<pre>
db.products.find({},{for:1})
</pre>

After creating the index, query products that work with an "ac3" phone; that is, "ac3" is present in the product's "for" field.
<ul>
<li>Q1: How many are there?</li>
<li>Q2: Run an explain plan on the above query.  How many records were scanned? </li>
<li>Q3: Was an index used?</li>
</ul>
<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>Q1: 0<endouttext/></choice><choice correct='false'><startouttext/>Q1: 1<endouttext/></choice><choice correct='false'><startouttext/>Q1: 3<endouttext/></choice><choice correct='true'><startouttext/>Q1 : 4<endouttext/></choice><choice correct='false'><startouttext/>Q2 : 1<endouttext/></choice><choice correct='true'><startouttext/>Q2 : 4<endouttext/></choice><choice correct='false'><startouttext/>Q2 : 5<endouttext/></choice><choice correct='false'><startouttext/>Q2 : 12<endouttext/></choice><choice correct='false'><startouttext/>Q3 : No<endouttext/></choice><choice correct='true'><startouttext/>Q3 : Yes<endouttext/></choice></checkboxgroup></choiceresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.5'><problem showanswer='never' attempts='3' url_name='Homework_2_5_problem' rerandomize='onreset' display_name='Quiz'>Referring back to 2.4 above, update those products (products that work with an "ac3" phone) and add 2 to the "price" of each of those items.

Then, at the shell prompt type: 
<pre>
homework.c()
</pre>

What is the output?<customresponse><textbox rows='4' cols='50' correct_answer="89.5954.5"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''89.5954.5'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential></chapter></course>