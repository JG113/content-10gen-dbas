<course url_name='2012_Fall' org='10gen' course='M102' start='2012-10-22T00:00' display_name='MongoDB for DBAs'>
<chapter start='2012-10-22T00:00' display_name='week1'>
<sequential graded='false' display_name='Course Overview'>
<vertical>
<video display_name='Lecture' youtube='1.0:0euni8AdT1c'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Concepts and Philosophy'>
<vertical>
<video display_name='Lecture' youtube='1.0:QUuYrMSPhL4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing on Unix'>
<vertical>
<video display_name='Lecture' youtube='1.0:6VFukRETCTg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing MongoDB on Windows'>
<vertical>
<video display_name='Lecture' youtube='1.0:hX5louVryOQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Types' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:gKOcqNHmc4Q'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Types_problem' rerandomize='never' display_name='Quiz: JSON Types'>
How many data types are there in JSON?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>1 (just strings)</text></choice>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
<choice location='bottom' correct='true'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:e2lfdSDENjY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Syntax' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:a3jWXcmjrWM'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Syntax_problem' rerandomize='never' display_name='Quiz: JSON Syntax'>
<p>What is the corresponding JSON for the following XML document?</p>

<pre>
&lt;person&gt;
  &lt;name&gt;John&lt;/name&gt;
  &lt;age&gt;25&lt;/age&gt;
  &lt;address&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phones&gt;
    &lt;phone type="home"&gt;212-555-1234&lt;/phone&gt;
    &lt;phone type="mobile"&gt;646-555-1234&lt;/phone&gt;
  &lt;/phones&gt;
&lt;/person&gt;
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer='{&#10;  "name" : "John",&#10;  "age" : 25,&#10;  "address" : {&#10;    "city" : "New York",&#10;    "postalCode" : "10021"&#10;  },&#10;  "phones" : [&#10;    {"phone":"212-555-1234", "type" : "home"},&#10;    {"phone":"646-555-1234", "type" : "mobile"}&#10;  ]&#10;}'> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{
  "name" : "John",
  "age" : 25,
  "address" : {
    "city" : "New York",
    "postalCode" : "10021"
  },
  "phones" : [
    {"phone":"212-555-1234", "type" : "home"},
    {"phone":"646-555-1234", "type" : "mobile"}
  ]
}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:RoUvl8c_3Sc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Syntax 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:dxd1BnBqQk8'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Syntax_2_problem' rerandomize='never' display_name='Quiz: JSON Syntax 2'>
For the following XML, Is the corresponding JSON example legal json?

<pre>
&lt;things&gt;
  &lt;hat&gt;one&lt;/hat&gt;
  &lt;coat&gt;z&lt;/coat&gt;
  &lt;hat&gt;two&lt;/hat&gt;
&lt;/things&gt;
</pre>

<pre>
{
  "hat" : "one",
  "coat" : "z",
  "hat" : "two"
}
</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>yes</text></choice>
<choice location='bottom' correct='false'><text>no</text></choice>
<choice location='bottom' correct='true'><text>maybe</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:eypM73cF0dI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to BSON'>
<vertical>
<video display_name='Lecture' youtube='1.0:CEH0kNxVyMw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='What is the Mongo Shell'>
<vertical>
<video display_name='Lecture' youtube='1.0:W4o8HJyL7_8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='What is JavaScript'>
<vertical>
<video display_name='Lecture' youtube='1.0:n1Hld15pvZY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='What is JavaScript 2'>
<vertical>
<video display_name='Lecture' youtube='1.0:n79mmmQxoNE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='mongoimport' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ZWnHhKiApVU'/>
</vertical>
<problem showanswer='attempted' url_name='mongoimport_problem' rerandomize='never' display_name='Quiz: mongoimport'>
The mongoimport utility can import what types of data?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>CSV (comma separated values)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>TSV (tab separated values)<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>XML<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>JSON<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>BSON<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>plain text<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:8_6S7E9r9DQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to the MongoDB Shell'>
<vertical>
<video display_name='Lecture' youtube='1.0:P1yLtecuLM8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Shell: Queries' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Mjcd5PAdG-s'/>
</vertical>
<problem showanswer='attempted' url_name='Shell_Queries_problem' rerandomize='never' display_name='Quiz: Shell: Queries'>
We have sample documents in our products collection such as:

<pre>
{
  name: "AC1 Case Green",
  color: "green",
  price: 12.00,
  for: "ac1",
  type: ["accessory", "case"],
  available: true
}
</pre>

How would we query in the shell for all products that are cases for an ac9 phone?  That is, where <i>type</i> contains the value "case" and <i>for</i> equals "ac9"?

<p><i>Please use field names in the order they appear in the question and use double quotes around values.</i></p><customresponse>
<textbox rows='4' cols='50' correct_answer='db.products.find({type: "case", for: "ac9"})'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.products.find({type: "case", for: "ac9"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:fYcPCRCPvDg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Shell:  Sorting'>
<vertical>
<video display_name='Lecture' youtube='1.0:Ezx1lXaY7jE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Shell: Cursors and Shell Help' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:DRs4_hBpPlI'/>
</vertical>
<problem showanswer='attempted' url_name='Shell_Cursors_and_Shell_Help_problem' rerandomize='never' display_name='Quiz: Shell: Cursors and Shell Help'>
What would you type to see the help/man text for mongo cursors in the mongo administrative shell?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>help</text></choice>
<choice location='bottom' correct='false'><text>db.help()</text></choice>
<choice location='bottom' correct='false'><text>db.products.help()</text></choice>
<choice location='bottom' correct='false'><text>help misc</text></choice>
<choice location='bottom' correct='true'><text>db.products.find().help()</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:3KwsHVHBM9w'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.1' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_1_problem' rerandomize='never' display_name='Quiz: Homework 1.1'>
Download and install MongoDB from www.mongodb.org.  Then run the database as a single server instance on your PC (that is, run the mongod binary).  Then, run the administrative shell.  From the shell prompt type 
<pre>
 db.isMaster().maxBsonObjectSize
</pre>
at the ">" prompt. What do you get as a result?<customresponse>
<textbox rows='4' cols='50' correct_answer="16777216"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''16777216'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 1.2' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_2_problem' rerandomize='never' display_name='Quiz: Homework 1.2'>
Download the file <a href="/static/handouts/products.json">products.json</a> from education.10gen.com.
Take a look at its content.
Now, import its contents into MongoDB, into a database called "pcat" and a collection called "products".  Use the mongoimport utility to do this.
When done, run this query in the mongo shell:
<pre>
db.products.find({type:"case"}).count()
</pre>
What's the result?<customresponse>
<textbox rows='4' cols='50' correct_answer="3"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 1.3' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_3_problem' rerandomize='never' display_name='Quiz: Homework 1.3'>
At this point you should have pcat.products loaded from the previous step. You can confirm this by running in the shell:
<pre>
> db.products.find()
> // or:
> db.products.count()
> // should print out "11"
</pre>
Now, what query would you run to get all the products where brand equals the string “ACME”?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.products.find({brand:"ACME"})'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.products.find({brand:"ACME"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 1.4' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_4_problem' rerandomize='never' display_name='Quiz: Homework 1.4'>
How would you print out, in the shell, the name of all the products without extraneous characters or braces, sorted alphabetically, ascending?  (Check all that would apply.)<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.products.find({},{name:1,_id:0}).sort({name:1})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>var c = db.products.find({},{name:1,_id:0}).sort({name:1}); 
while( c.hasNext() ) 
    print( c.next().name);
<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>var c = db.products.find({}).sort({name:1});
c.forEach( function(doc){ print(doc.name) } );<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>var c = db.products.find({}).sort({name:-1});
while( c.hasNext() ) 
    print( c.next().name);<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-10-29T00:00' display_name='week2'>
<sequential graded='false' display_name='Inserting Data' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:MWH-_nJgebw'/>
</vertical>
<problem showanswer='attempted' url_name='Inserting_Data_problem' rerandomize='never' display_name='Quiz: Inserting Data'>
In the mongo shell, what would you type to insert the document {x:3,y:4} into the "temperature" collection for the current database?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.temperature.insert({x:3,y:4})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.temperature.insert({x:3,y:4})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Yl6L0jytr4o'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Updating Documents' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:0tGJGxqvO0c'/>
</vertical>
<problem showanswer='attempted' url_name='Updating_Documents_problem' rerandomize='never' display_name='Quiz: Updating Documents'>
Suppose we have a collection "cars" with one document preexisting:
<pre>
{ "_id" : 100, "name" : "GTO", 
  "year" : 1969, "color" : "red" }
</pre>
Which of the following statements would set "available" to 1?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>db.cars.update({_id:100},{$set:{available:1}})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.cars.update({_id:100},{$inc:{available:1}})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.cars.update({},{$inc:{available:1,year:1970}})<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:sRjVWZ6olqI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='MongoDB Documents Quiz' format='Quiz'>
<problem showanswer='attempted' url_name='MongoDB_Documents_Quiz_problem' rerandomize='never' display_name='Quiz: MongoDB Documents Quiz'>
Which of the following are true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>MongoDB can store large things; for example a 1 terabyte video.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>On an update of a document in mongodb, the document always physically moves in its position in the data file(s).<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>On average, mongodb documents have about the same number of fields as one would have in a relational database table for the same problem.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='Removing documents' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:qj7n4TRVY1M'/>
</vertical>
<problem showanswer='attempted' url_name='Removing_documents_problem' rerandomize='never' display_name='Quiz: Removing documents'>
Suppose we have documents in a 'users' collection of the form:
<pre>
{
 _id : ObjectId("50897dbb9b96971d287202a9"),
 name : "Jane",
 likes : [ "tennis", "golf" ],
 registered : false,
 addr : {
   city : "Lyon",
   country : "France" 
 } 
}
</pre>
How would we, in the mongo shell, delete all documents in the collection where city = "Lyon" and registered is false?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.remove({"addr.city":"Lyon",&#10;registered:false})'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.remove({"addr.city":"Lyon",
registered:false})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WOzekUwo1vE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Updating Part 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pgu3nta2iLM'/>
</vertical>
<problem showanswer='attempted' url_name='Updating_Part_2_problem' rerandomize='never' display_name='Quiz: Updating Part 2'>
Suppose we have documents in a 'users' collection of the form:
<pre>
{
 _id : "Jane",
 likes : [ "tennis", "golf" ],
 registered : false,
 addr : {
   city : "Lyon",
   country : "France" 
 } 
}
</pre>
How would we, in the mongo shell, add that this user likes "football"?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.update({_id:"Jane"},{$addToSet:{likes:"football"}}, true)'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({_id:"Jane"},{$addToSet:{likes:"football"}}, true)'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:zKDmE590nlA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='MongoDB Commands'>
<vertical>
<video display_name='Lecture' youtube='1.0:nAfLu7vKiRI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='MongoDB Commands 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:0tnBD_hLUso'/>
</vertical>
<problem showanswer='attempted' url_name='MongoDB_Commands_2_problem' rerandomize='never' display_name='Quiz: MongoDB Commands 2'>
Which of these statements is true?
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>MongoDB commands are for administrator use only.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>In MongoDB collections are usually created implicitly.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>In MongoDB indexes are usually created implicitly.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uktnp4cIjZk'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.1' format='Homework' due='Nov 8 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_1_problem' rerandomize='never' display_name='Quiz: Homework 2.1'>
We will use the pcat.products collection from week 1.  So start with that; if not already set up, import it:
<pre>
mongoimport --db pcat -c products &lt; products.json
</pre>
You can find <a href="/static/handouts/products.json">products.json</a> on the education.10gen.com site. 
In the shell, if you type:
<pre>
db.products.count()
</pre>

should return 11.
<p>
Next, download <a href="/static/handouts/homework2.js">homework2.js</a> from the education.10gen.com site.  Run the shell with this script:</p>
<pre>
mongo --shell pcat homework2.js
</pre>

First, make a mini-backup of the collection before we start modifying it.  In the shell:

<pre>
b = db.products_bak; db.products.find().forEach( function(o){ b.insert(o) } )
 // check it worked: 
b.count()
// should print 11
</pre>

If you have any issues you can restore from "products_bak"; or, you can re-import with mongoimport.  (You would perhaps need in that situation to empty the collection first or drop it; see the --drop option on mongoimport --help.)

At the shell ">" prompt type: 
<pre>
homework.a()
</pre>

What is the output? (The above will check that products_bak is populated.)<customresponse>
<textbox rows='4' cols='50' correct_answer="3.05"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3.05'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:r8szX-Q-3Hg'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.2' format='Homework' due='Nov 8 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_2_problem' rerandomize='never' display_name='Quiz: Homework 2.2'>
Add a new product to the products collection of this form:
<pre>
{
	"_id" : "ac9",
	"name" : "AC9 Phone",
	"brand" : "ACME",
	"type" : "phone",
	"price" : 333,
	"warranty_years" : 0.25,
	"available" : true
}
</pre>
Note: in general because of the automatic line continuation in the shell, you can cut/paste in the above and shouldn't have to type it all out.  Just enclose it in the proper statement(s) to get it added.

Next, load into a shell variable the object corresponding to 
<pre>
_id : ObjectId("507d95d5719dbef170f15c00")
</pre>
<ul>
<li>Then change <code>term_years</code> to 3 for that document. (And save that to the database.)</li>
<li>Then change <code>over_rate</code> for <code>sms</code> in <code>limits</code> to 0.01 from 0.  Save that too.</li>
</ul>
At the shell prompt type: 
<pre>
homework.b()
</pre>
What is the output?<customresponse>
<textbox rows='4' cols='50' correct_answer="0.050.019031"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''0.050.019031'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:AKAxnShI8sU'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.3' format='Homework' due='Nov 8 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_3_problem' rerandomize='never' display_name='Quiz: Homework 2.3'>
How many products have a voice limit?  (That is, have a voice field present in the limits array.)<customresponse>
<textbox rows='4' cols='50' correct_answer="3"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''3'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:qn0jv7PMO0U'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.4' format='Homework' due='Nov 8 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_4_problem' rerandomize='never' display_name='Quiz: Homework 2.4'>
Create an index on the field <code>for</code>.

You might want to first run the following to get some context on what is present in that field in the documents of our collection:
<pre>
db.products.find({},{for:1})
</pre>

After creating the index, query products that work with an "ac3" phone; that is, "ac3" is present in the product's "for" field.
<ul>
<li>Q1: How many are there?</li>
<li>Q2: Run an explain plan on the above query.  How many records were scanned? </li>
<li>Q3: Was an index used?</li>
</ul>
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Q1: 0<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q1: 1<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q1: 3<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Q1 : 4<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q2 : 1<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Q2 : 4<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q2 : 5<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q2 : 12<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Q3 : No<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Q3 : Yes<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pIXPARhDfRE'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.5' format='Homework' due='Nov 8 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_5_problem' rerandomize='never' display_name='Quiz: Homework 2.5'>
Referring back to 2.4 above, update those products (products that work with an "ac3" phone) and add 2 to the "price" of each of those items.

Then, at the shell prompt type: 
<pre>
homework.c()
</pre>

What is the output?<customresponse>
<textbox rows='4' cols='50' correct_answer="89.5954.5"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''89.5954.5'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:A5_7rx3GNs4'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-11-08T00:00' display_name='week3'>
<sequential graded='false' display_name='Week3 Intro'>
<vertical>
<video display_name='Lecture' youtube='1.0:0e02eUHMSUw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ufiFaY995GQ'/>
</vertical>
<problem showanswer='attempted' url_name='Schema_Design_problem' rerandomize='never' display_name='Quiz: Schema Design'>
Imagine we are building an order processing system.  Customers can have many orders; each order can have many line items.  Which schema is most typical in MongoDB?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>customers collection, orders collection, order_line_items collection</text></choice>
<choice location='bottom' correct='true'><text>customers collection, orders collection</text></choice>
<choice location='bottom' correct='false'><text>orders collection only</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:FHQszgGukfY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Aggregation Framework 1'>
<vertical>
<video display_name='Lecture' youtube='1.0:OOciY22Eqpc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Aggregation Framework 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:5ApeWrsjOJY'/>
</vertical>
<problem showanswer='attempted' url_name='The_Aggregation_Framework_2_problem' rerandomize='never' display_name='Quiz: The Aggregation Framework 2'>
Suppose we have postal code (zip code) data of the form:
<pre>{
  "_id": "10280",
  "city": "NEW YORK",
  "state": "NY",
  "pop": 5574,
  "loc": [
    -74.016323,
    40.710537
  ]
}</pre>
in a collection postal_codes. (In the example above '10280' is a U.S. postal code / zip code.)  We want to find which cities have the most zip codes, and print the top 5 cities.  We want to handle the fact that some states have a city with the same name as another state and treat the cities as different in that case.   We run:
<pre>
&gt; db.postal_codes.aggregate( [ 
 {$group:{_id:{state:"$state",city:"$city"},
    n:{$sum:1}}} , 
 {$sort:{n:-1}} , 
 {$limit:5} ] 
)</pre>
Which of the following is true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>In the above {city:”$city”,state:"$state"} would work fine instead of {state:"$state",city:"$city"}, albeit with a slightly different output presentation.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/> {x:"$state",y:"$city"} would work fine albeit with a slightly less clear output presentation.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>To get the states with the most postal codes we would simply do {state:"$state"} instead of {state:"$state",city:"$city"}.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>If our documents are not consistent about the capitalization of the city names, we need to do something special AND there is a way to do that with the aggregation framework.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:LhmYVl6VkSs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='More $ operators' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:StPhSsIkOh0'/>
</vertical>
<problem showanswer='attempted' url_name='More_operators_problem' rerandomize='never' display_name='Quiz: More $ operators'>
Suppose we have documents in a collection of the form 
<pre>{ _id : …, x : [
  { a : …, b : … },
  { a : …, b : … },
  { a : …, b : …, c : ... }, ...
] }</pre>
We want to find all the top level documents which have a subobject in their x array where for that subobject a == 1 and b == 3.  Which of these queries does that?  Check all that are correct.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.things.find( { “x.a” : 1, “x.b” : 3 } )<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.things.find( { x : { a : 1, b : 3 } } )<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.things.find( { x : { $elemMatch : { a:1,b:3} } } )
<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:nxoM7vRQ7h8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The findAndModify Command' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:1EQ31ggRcJc'/>
</vertical>
<problem showanswer='attempted' url_name='The_findAndModify_Command_problem' rerandomize='never' display_name='Quiz: The findAndModify Command'>
Which of these statements are true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>findAndModify is atomic.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Update operations which update a single document are atomic.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Usually, update is faster than findAndModify.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:C5QIGAi2zFs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Map Reduce' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:rqcbyw8Zcvg'/>
</vertical>
<problem showanswer='attempted' url_name='Map_Reduce_problem' rerandomize='never' display_name='Quiz: Map Reduce'>
MongoDB's built-in map/reduce can do the equivalent of the aggregation framework's $unwind operator.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>True</text></choice>
<choice location='bottom' correct='false'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:yFBKf3VEvnk'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 3.1' format='Homework' due='Nov 19 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_3_1_problem' rerandomize='never' display_name='Quiz: Homework 3.1'>
Download the file <a href="http://media.mongodb.org/zips.json">http://media.mongodb.org/zips.json</a>.  The example below uses "curl", but you can download with your web browser if you like.  ("Zip codes" are the U.S. version of postal codes; they are 5 digits long.)

Then import this file into a collection "zips". 
<pre>
$ curl -O http://media.mongodb.org/zips.json
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 2803k  100 2803k    0     0  1807k      0  0:00:01  0:00:01 --:--:-- 1848k
$
$ # this is just informational for you:
$ md5 zips.json
MD5 (zips.json) = 4854d69c2ac389f334c0abff03d96259
$
$ # now import it ...
</pre>
After import you will find 29467 documents in your zips collection -- note this is slightly different than the .json file as the zips.json file is a bit noisy in its data and has some duplicate keys (duplicate _id's):
<pre>
$ mongo
> db.zips.count()
29467
</pre>
Question: consider the state with the 4th most zip codes in it.  How many zip codes does that state have?  Use the aggregation framework to query this.<customresponse>
<textbox rows='4' cols='50' correct_answer="1458"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''1458'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 3.2' format='Homework' due='Nov 19 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_3_2_problem' rerandomize='never' display_name='Quiz: Homework 3.2'>
Use the same zips collection we imported in homework 3.1.  You can confirm you have the right data (well, the count of documents at least) via:
<pre>
&gt; db.zips.count()
29467
</pre>
Now use the aggregation framework to check the data quality.  First let's check how many zip documents have a starting zip code digit of each possible character:
<pre>
&gt; db.zips.aggregate( 
...   [
...     { $project : { _id : { $substr : ["$_id",0,1] } } } , 
...     { $group : { _id : "$_id", n : {$sum:1} } }
...   ]
... )
{
	"result" : [
		{
			"_id" : "5",
			"n" : 3624
		},
		{
			"_id" : "4",
			"n" : 3387
		},
		{
			"_id" : "6",
			"n" : 3540
		},
        …
</pre>
Now check in a similar manner the "city" field for its first character.  You will find there are cities in the collection that start with a number -- which indicates either a noisy data set or zip codes that have no corresponding city.  Let's suppose we want to delete these zip code documents -- the ones that have a numeric city name -- from our data set.  Do a remove operation to delete those documents.
<p>
After removing the documents indicated above, how many documents remain in the zips collection?
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="29353"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''29353'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 3.3' format='Homework' due='Nov 19 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_3_3_problem' rerandomize='never' display_name='Quiz: Homework 3.3'>
Download <a href="/static/handouts/week3.js">week3.js</a> from the education.10gen.com site.

Run this file in the shell to populate in the database of your choice a few documents in collections called:
<pre>
- policies
- customers
- staffers
</pre>
(Note some of these may be used in future weeks.)
<p>
Once loaded, query each collection above and verify they are non-empty.  In particular run:
</p>
<pre>
  db.policies.find().pretty() 
</pre>
to format the output of the one policy loaded nicely.
<p>
We have been asked to find all policies that are status!="expired", with liability coverage at or above $100.  Note that current:true indicates the rate that is "current" and not historical.
</p>
<p>
The query to find those policies is which of the following?
</p><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>db.policies.find(
 { status : { $ne : "expired" }, 
   coverages : { 
     $elemMatch : {
       type : "liability", 
       rates : { 
         $elemMatch : {
           rate : { $gte : 100 }, 
           current : true 
         }
       }
     }
   }
 }
)</text></choice>
<choice location='bottom' correct='false'><text>db.policies.find(
 { status : { $ne : "expired" }, 
   coverages : { 
     $elemMatch : {
       type : "liability", 
       rates : { 
           rate : { $gte : 100 }, 
           current : true 
       }
     }
   }
 }
)</text></choice>
<choice location='bottom' correct='false'><text>db.policies.find(
 { status : { $ne : "expired" }, 
   coverages : { 
       type : "liability", 
       rates : { 
         $elemMatch : {
           rate : { $gte : 100 }, 
           current : true 
         }
       }
   }
 }
)</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 3.4' format='Homework' due='Nov 19 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_3_4_problem' rerandomize='never' display_name='Quiz: Homework 3.4'>
<p>
Use the built-in Map/Reduce functionality in MongoDB to answer the following question: of the zip codes in Pennsylvania, how many are closer to Pittsburgh and how many are closer to Philadelphia?
</p>
<p>
The map function is already written for you.  (Note it uses some lat/longs that are somewhat arbitrary and not exactly the center of those cities.)  Our map function assumes the world is flat -- for this problem assume that assumption is ok.
</p><p>
(Aside: note that MongoDB does have some geospatial features; the problem could also be solved using more than one query and a geospatial index. However here our goal is to use map / reduce and try it out. In fact the MongoDB geospatial features would handle the world-not-flat issue…)
</p><p>
The map function is provided in the aforementioned week3.js file.  Thus if you run:
</p><pre>
mongo --shell week3.js
</pre><p>
The method map_closest() will already be defined.  You can type it at the shell prompt without parameters to see its source code:
</p><pre>
> map_closest
function map_closest() {
    var pitt = [-80.064879, 40.612044];
    var phil = [-74.978052, 40.089738];

    function distance(a, b) {
        var dx = a[0] - b[0];
        var dy = a[1] - b[1];
        return Math.sqrt(dx * dx + dy * dy);
    }

    if (distance(this.loc, pitt) &lt; distance(this.loc, phil)) {
        emit("pitt", 1);
    } else {
        emit("phil", 1);
    }
}
&gt; 
</pre><p>
Question: How many zip codes in PA are closer to philadelphia than to pittsburgh (given our map function's implementation)?  Use map/reduce to find the answer.</p><customresponse>
<textbox rows='4' cols='50' correct_answer="732"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''732'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-11-16T00:00' display_name='week4'>
<sequential graded='false' display_name='Introduction to replication' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:zlxV8h5fSN0'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_replication_problem' rerandomize='never' display_name='Quiz: Introduction to replication'>
Which are true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>MongoDB replication is synchronous.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>MongoDB replication works over wide area network connections.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB supports multi-master replication.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>MongoDB uses statement based replication.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Statement based replication is the most efficient approach.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:UhruOnk_gd4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Sets Overview' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ixheNHq1qvw'/>
</vertical>
<problem showanswer='attempted' url_name='Replica_Sets_Overview_problem' rerandomize='never' display_name='Quiz: Replica Sets Overview'>
Which of the following statements are true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Replica sets support automatic failover.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>It's not unusual to have a set with two members.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Failed nodes, if they come back up, automatically recover.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Failed nodes, if they come back up, automatically recover.  Upon recovery any local writes which had not formerly propagated are merged into the data sets of the other members of the set.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='Replica Set Demo'>
<vertical>
<video display_name='Lecture' youtube='1.0:iEnioS8n254'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Set Demo (windows)'>
<vertical>
<video display_name='Lecture' youtube='1.0:UVvU7soWXqg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Sets - the simple http admin UI' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:vDgF0-HU9fE'/>
</vertical>
<problem showanswer='attempted' url_name='Replica_Sets_the_simple_http_admin_UI_problem' rerandomize='never' display_name='Quiz: Replica Sets - the simple http admin UI'>
Which are true statements?

Note: replica set "arbiters" do not have an oplog; disregard that for this discussion we are referring to "normal" members of the set.  Arbiters will be covered in an upcoming section.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>All the members of the set always have the same oplog start time.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>All the members of the set always have the same oplog end time.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>For a given database write / statement, on all members of the set who have received and applied the operation, the optime time stamp i their oplogs will all be exactly the same value.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>If --rest is on you can query the mongod via REST (via HTTP).<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cKEqGCms17w'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Set Configuration' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Dul7SbTVgvs'/>
</vertical>
<problem showanswer='attempted' url_name='Replica_Set_Configuration_problem' rerandomize='never' display_name='Quiz: Replica Set Configuration'>
Suppose we wish to have a three node replica set with one member in a remote disaster recovery data center.  How do we configure such that the DR node never automatically becomes primary?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Set priority:0 for the DR node/member in its configuration object.</text></choice>
<choice location='bottom' correct='false'><text>Set hidden:true for the DR node/member in its configuration object.</text></choice>
<choice location='bottom' correct='false'><text>When clients connect to the set, they list the preferred members only in their connect strings and not the DR node's name.</text></choice>
<choice location='bottom' correct='false'><text>This is not supported.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:9FLuW1ycRGg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='GetLasterror and cluster wide commits' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:uCZc78FD03c'/>
</vertical>
<problem showanswer='attempted' url_name='GetLasterror_and_cluster_wide_commits_problem' rerandomize='never' display_name='Quiz: GetLasterror and cluster wide commits'>
for getLastError / WriteConcern with w=3, if you have an arbiter, it counts as one of the 3.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>True</text></choice>
<choice location='bottom' correct='true'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5WE0N4tCZqY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='GetLastError Quiz 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:2IE2nBD5phs'/>
</vertical>
<problem showanswer='attempted' url_name='GetLastError_Quiz_2_problem' rerandomize='never' display_name='Quiz: GetLastError Quiz 2'>
You can delete members from a replica set.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>true</text></choice>
<choice location='bottom' correct='false'><text>false</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:GIrmxlR8CA0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multi data center and sample configurations'>
<vertical>
<video display_name='Lecture' youtube='1.0:TZOH92mZIN8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='ReadPreference (slaveOk)' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:IDzKHRyiE18'/>
</vertical>
<problem showanswer='attempted' url_name='ReadPreference_slaveOk__problem' rerandomize='never' display_name='Quiz: ReadPreference (slaveOk)'>
Why might one use "secondaryPreferred" instead of "secondary" Read Preference?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The primary may have fresher data and we would like to use it.</text></choice>
<choice location='bottom' correct='true'><text>The secondaries may be down.</text></choice>
<choice location='bottom' correct='false'><text>To reduce load on the primary.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:9LEg_4Qc-04'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 4.1' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_4_1_problem' rerandomize='never' display_name='Quiz: Homework 4.1'>
In this week’s homework we will create a replica set and add some data to it.
<br />
1. Download <a href="/static/handouts/week4.js">week4.js</a> from the education.10gen.com site.
<br />
2. We will create a three member replica set.  Pick a root working directory to work in.  Go to that directory in a console window.  
<br />
Given we will have three members in the set, and three mongod processes, create three data directories: 
<pre>
mkdir 1
mkdir 2
mkdir 3
</pre>
<br />
3. We will now start a single mongod as a standalone server.  Given we will have three mongod processes on our single test server, we will explicitly specify the port numbers (this wouldn’t be necessary if we had three real machines or three virtual machines).  We’ll also use the --smallFiles parameter and --oplogSize so the files are small given we have a lot of server processes running on our test PC.
<pre>
# starting as a standalone server for problem 1:
mongod --dbpath 1 --port 27001 --smallfiles --oplogSize 50
</pre>
Note: for all mongod startups in the homework this week, you can optionally use --logPath,  --logAppend, and --fork.  Or, since this is just an exercise on a local PC, you could simply have a separate terminal window for all and forgoe those settings.  Run “mongod --help” for more info on those.

<br />
4. In a separate terminal window (cmd.exe on Windows), run the mongo shell with the week4.js file:

<pre>
mongo --port 27001 --shell week4.js
</pre>

Then run in the shell:
<pre>
  > homework.init()
</pre>

This will load a small amount of test data into the database.

<br />
Now run 

<pre>
 > homework.a()
</pre>

and enter the result.  This will simply confirm all the above happened ok.<customresponse>
<textbox rows='4' cols='50' correct_answer="5001"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''5001'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 4.2' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_4_2_problem' rerandomize='never' display_name='Quiz: Homework 4.2'>
Now convert the mongod instance (the one in the problem 4.1 above, which uses “--dbpath 1”) to a single server replica set.  To do this, you’ll need to stop the mongod and restart it with “--replSet” on its command line.  Give the set any name you like.
<br />
Then go to the mongo shell.  You should see some data in the week4 database.  You can confirm with:

<pre>
> use week4
> db.foo.find()
</pre>

Once done with that run
<pre>
 > homework.b()
</pre>

in the mongo shell and enter that result.<customresponse>
<textbox rows='4' cols='50' correct_answer="5002"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''5002'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 4.3' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_4_3_problem' rerandomize='never' display_name='Quiz: Homework 4.3'>
Now add two more members to the set.  Use the 2/ and 3/ directories we created in homework 4.1.  Run those two mongod’s on ports 27002 and 27003 respectively (the exact numbers could be different).
<p />
Connect to one of those new members from the shell for example 

<pre>
mongo --port 27002 week4.js --shell
</pre>

One the servers have sync’d with the primary and are caught up run:

<pre>
> homework.c()
</pre>

and enter the result.<customresponse>
<textbox rows='4' cols='50' correct_answer="5"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''5'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 4.4' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_4_4_problem' rerandomize='never' display_name='Quiz: Homework 4.4'>
We will now retire the first member (@ port 27001) from the set (remove it that is).
<br />

As a first step to doing this we will shut it down.  (Given the rest of the set can maintain a majority, we can still do a majority reconfiguration if it is down.)
<br />
We could simply terminate its mongod process, but if we use the replSetStepDown command, the failover may be faster.  So that is a good practice albeit not essential.  Connect to member 1 (port 27001) in the shell and run: 

<pre>
> rs.help()
> rs.stepDown(300)
</pre>

Then cleanly terminate the mongod process for member 1.
<br />

Next, go to the new primary of the set.  Run rs.status() to check that things are as you expect.  Then, reconfigure to remove member 1.  Tip: if new to javascript you may find the Array.shift() method helpful for example try this in the shell:

<pre>
> my_array = [‘a’,’b’,’c’]
> my_array.shift()
> my_array
>
</pre>

When done, run

<pre>
> homework.d()
</pre>

and enter the result.  (If you ran the shell without week4.js on the command line, run it again with that.)<customresponse>
<textbox rows='4' cols='50' correct_answer="6"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''6'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 4.5' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_4_5_problem' rerandomize='never' display_name='Quiz: Homework 4.5'>
<p>Note our replica set now only has an even number of members, and that is not a best practice.  However, to keep the homework from getting too long we’ll leave it at that for now, and instead do one more exercise below involving the <i>oplog</i>.
</p>
<p>
Go to the secondary in the replica set.  Run this to verify you are on the secondary:
</p>
<pre>
> // expect to get back false as we are not primary
> db.isMaster().ismaster
false
</pre>

Switch to the local database and then look at the oplog:

<pre>
> db.oplog.rs.find()
</pre>
<p>
If you get a blank result, you are not on the right database.
</p>
<p>
Note: as the local database doesn’t replicate, it will let you query it without entering “rs.slaveOk()” first.
</p>
<p>
Note: you may wonder why the number of lines in the oplog is the number you see here.  See the homework answer video when answers are posted for more information if curious.
</p>
<p>
Next look at the stats on the oplog to get a feel for its size:
</p>
<pre>
> db.oplog.rs.stats()
</pre>

What result does this expression give when evaluated?

<pre>
db.oplog.rs.find().sort({$natural:1}).limit(1).next().o.msg[0]
</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>N</text></choice>
<choice location='bottom' correct='false'><text>n</text></choice>
<choice location='bottom' correct='false'><text>Blank</text></choice>
<choice location='bottom' correct='true'><text>R</text></choice>
<choice location='bottom' correct='false'><text>r</text></choice>
<choice location='bottom' correct='false'><text>I</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-11-23T00:00' display_name='week5'>
<sequential graded='false' display_name='Week5 Intro'>
<vertical>
<video display_name='Lecture' youtube='1.0:TjSa45rEoYw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Indexes and Optimizing Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:a7TrHP1C6qQ'/>
</vertical>
<problem showanswer='attempted' url_name='Indexes_and_Optimizing_Performance_problem' rerandomize='never' display_name='Quiz: Indexes and Optimizing Performance'>
Quiz: a mongodb index can have keys of different types (ints, dates, string for example) in it?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>True</text></choice>
<choice location='bottom' correct='false'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:p-rVdi50E74'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Types' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:DFfCC8Or8_U'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Types_problem' rerandomize='never' display_name='Quiz: Index Types'>
Quiz: typically, what’s the best index for this query, assuming we have lots of queries compared to writes?

<pre>
db.users.find( { last:"smith", first:"john" } )
</pre>

Fill in the blank:

<pre>
db.users.ensureIndex({___})
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer='{"last":1,"first":1}'> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{"last":1,"first":1}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:KFXYaOVtyPo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Covered Indexes' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:boAkBnMUBnw'/>
</vertical>
<problem showanswer='attempted' url_name='Covered_Indexes_problem' rerandomize='never' display_name='Quiz: Covered Indexes'>
Suppose we run:
<pre>
db.foo.ensureIndex({a:1,b:2,c:3})
db.foo.find({a:"sports", b:{$gt:100}})
</pre>
Then<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Only the index needs to be touched to fully execute the query (the find() statement).</text></choice>
<choice location='bottom' correct='true'><text>The index and some documents need to be touched.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:UKOOJocN51E'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Explain and Hint' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:oaTm0Kftit8'/>
</vertical>
<problem showanswer='attempted' url_name='Explain_and_Hint_problem' rerandomize='never' display_name='Quiz: Explain and Hint'>
Hint always works.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>True</text></choice>
<choice location='bottom' correct='true'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:9gqnaoe43m0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Read vs. Write Tradeoffs' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:USDbDotmums'/>
</vertical>
<problem showanswer='attempted' url_name='Read_vs_Write_Tradeoffs_problem' rerandomize='never' display_name='Quiz: Read vs. Write Tradeoffs'>
We choose to create an index on x with default settings: 
<pre>
	db.foo.ensureIndex({x:1})
</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>If there are documents with no value for x, the index build will fail.</text></choice>
<choice location='bottom' correct='false'><text>If there are documents with no value for x, the index build will work and those documents aren’t in the index.
</text></choice>
<choice location='bottom' correct='true'><text>If there are documents with no value for x, the index build will work and those documents are in the index.
</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:g8AtXS5GgCw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='currentOp and killOp' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:i7XEKAtRS_M'/>
</vertical>
<problem showanswer='attempted' url_name='currentOp_and_killOp_problem' rerandomize='never' display_name='Quiz: currentOp and killOp'>
Which ops are safe to kill (without any special effort or cleanup or implications later beyond the obvious):
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>a query
<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>a findAndModify on a primary

<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>a foreground create index building on a primary<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>a foreground create index building on a secondary
<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>a compact command job<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:1GBM9ghVK9Y'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Profiler' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:MzLmI8FNB94'/>
</vertical>
<problem showanswer='attempted' url_name='The_Profiler_problem' rerandomize='never' display_name='Quiz: The Profiler'>
The profiler can tell you if updates are “moving”
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>True</text></choice>
<choice location='bottom' correct='false'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:qHZSuBCt7ew'/>
</vertical>
</sequential>
<sequential graded='false' display_name='mongostat and mongotop'>
<vertical>
<video display_name='Lecture' youtube='1.0:fEgl1DT_lDA'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 5.1' format='Homework' due='Dec 3 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_5_1_problem' rerandomize='never' display_name='Quiz: Homework 5.1'>
<p>Start a <code>mongod</code> server instance (if you still have your replica set from week 4 running, that would work too).
</p>
Next, download <a href="/static/handouts/week5.js">week5.js</a> and run:
<pre>
mongo --shell localhost/week5 week5.js
> homework.init()
>
</pre>
<p>
Assume our app development team for a project would like to speed up the following query:
</p><pre>
db.sensor_readings.find( { 
  tstamp : { 
    $gte : ISODate("2012-08-01"), 
    $lte :  ISODate("2012-09-01") 
  },
  active : true
} ).limit(3)
</pre><p>
Run the query, and explain().  Then create an index to speed up the query (with ensureIndex()).  Then run the explain() again and see that things have improved.  When you have a solution run: 
</p><pre>
homework.a()
</pre>
<p>
and enter the result below.
</p><p>
Note: if you would like to try different indexes, you can use 
<code>
db.sensor_readings.dropIndexes()</code> to drop your old index before creating a new one. (For this problem you will only need one index beyond the _id index which is present by default.)
</p>
<p>
Note: we are optimizing for the query <i>when the limit clause is present</i>.  So be use to include limit when you call explain.
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="6"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''6'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 5.2' format='Homework' due='Dec 3 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_5_2_problem' rerandomize='never' display_name='Quiz: Homework 5.2'>
<p>
In a mongo shell run <code>homework.b()</code>.  This will run in an infinite loop printing some output as it runs various statements against the server.
</p><p>
We'll now imagine that on this system a user has complained of slowness and we suspect there is a slow operation running.  Find the slow operation and terminate it.  (Keep the other shell with homework.b() going while this is happening).  Once you have eliminated the slow operation, run
</p><pre>
homework.c()
</pre><p>
and enter the output below.  Once you have it right and are ready to move on, ctrl-c (terminate) the shell that is still running the <code>homework.b()</code> function.</p><customresponse>
<textbox rows='4' cols='50' correct_answer="12"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''12'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Homework 5.3' format='Homework' due='Dec 3 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_5_3_problem' rerandomize='never' display_name='Quiz: Homework 5.3'>
<p>Compact the <code>week5.sensor_readings</code> collection.  Then run <code>homework.d()</code> and enter the result below.
</p><p><i>Note: If you happen to bee running a replica set, just compact on the primary and run homework.d() on the primary. You may need to use the <a href="http://docs.mongodb.org/manual/reference/command/compact/">force:true</a> option to run compact on a primary.</i></p><customresponse>
<textbox rows='4' cols='50' correct_answer="21"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''21'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-12-03T00:00' display_name='week 6'>
<sequential graded='false' display_name='Introduction to Sharding' format='Quiz'>
<problem showanswer='attempted' url_name='Introduction_to_Sharding_problem' rerandomize='never' display_name='Quiz: Introduction to Sharding'>
<pre>db.foo.find( 
  { name : { $gt : “Joe”, $lt : “John” } } ) </pre> is efficient if the collection is sharded on <code>{ name : 1 }</code><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>True</text></choice>
<choice location='bottom' correct='false'><text>False</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='Sharding Setup Demo' format='Quiz'>
<problem showanswer='attempted' url_name='Sharding_Setup_Demo_problem' rerandomize='never' display_name='Quiz: Sharding Setup Demo'>
Quiz: how many mongos processes should you run (generally)?

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>One per config server
</text></choice>
<choice location='bottom' correct='false'><text>One per mongod process
</text></choice>
<choice location='bottom' correct='false'><text>One per shard
</text></choice>
<choice location='bottom' correct='false'><text>One</text></choice>
<choice location='bottom' correct='true'><text>However many you want but usually much more than one
</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='The config database' format='Quiz'>
<problem showanswer='attempted' url_name='The_config_database_problem' rerandomize='never' display_name='Quiz: The config database'>
Which are true?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>To check via the mongo shell what's in the config database of a MongoDB cluster, you must connect it directly to one of the config servers.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Three config servers is typical in a MongoDB cluster with 1,000 total machines.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>All the config servers have exactly the same data.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='Setup Part 2' format='Quiz'>
<problem showanswer='attempted' url_name='Setup_Part_2_problem' rerandomize='never' display_name='Quiz: Setup Part 2'>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='false' display_name='Enabling sharding for a collection' format='Quiz'>
<problem showanswer='attempted' url_name='Enabling_sharding_for_a_collection_problem' rerandomize='never' display_name='Quiz: Enabling sharding for a collection'>
In MongoDB v2.2, unsharded collections are:<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>On the first shard</text></choice>
<choice location='bottom' correct='false'><text>Each non-sharded collection is homed on a shard at random</text></choice>
<choice location='bottom' correct='false'><text>Sharded on _id until specified otherwise</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
</chapter>
</course>
